"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ = require(".");
var assert = _interopRequireWildcard(require("assert"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Traverses a schema using a ref
class RefTraversal {
  constructor(ref, schema, rootType) {
    // Traverse the whole ref
    _defineProperty(this, "toEnd", () => {
      while (this.next()) {
        // Nothing
      }
      return this;
    });
    // Traverses one more path element
    _defineProperty(this, "next", () => {
      if (this._index >= this._ref.path.size - 1) {
        return false;
      }
      this._index++;
      const {
        name: parentTypeName
      } = this.type;
      const {
        name
      } = this._ref.path.get(this._index);
      if (!this._schemaTraversal.enterMember(name)) {
        throw new Error(`Path element "${name}" is not a member of type "${parentTypeName}"`);
      }
      return true;
    });
    assert.ok(ref, 'Invalid ref provided to RefTraversal constructor');
    assert.ok(schema, 'Invalid schema provided to RefTraversal constructor');
    // assert.ok(!rootType || typeof rootType === 'string', 'Invalid root type provided to RefTraversal constructor');

    ref = (0, _.$$)(ref);
    this._ref = ref;
    this._index = -1;
    if (rootType) {
      this._schemaTraversal = new _.SchemaTraversal(schema, rootType);
    } else if (ref.program) {
      const refSchema = schema.imports.find(i => i.name === ref.program);
      this._schemaTraversal = new _.SchemaTraversal(schema, refSchema.id + ':Root');
    } else {
      this._schemaTraversal = new _.SchemaTraversal(schema);
    }
  }
  getContext() {
    return this;
  }
  // TODO: this is not being used but if you want to use it feel free to
  // uncomment and fix
  // // Returns a ref traversal to an argument of the current path element
  // getArgTraversal(name) {
  //   const { args } = this;
  //   const param = this.member.params.find((f) => f.name === name);
  //   if (param === undefined) {
  //     throw new Error('Arg does not exist in the schema');
  //   }
  //   const argValue = this.args.get(name);
  //   if (argValue === undefined) {
  //     throw new Error('Arg does not exist in the current path element');
  //   }
  //   console.log('ARG', argValue);
  //   console.log('PARAM', param);
  //   if (!(argValue instanceof Ref)) {
  //     throw new Error('Only Ref arguments can be used');
  //   }
  //
  //   // const schema = this.schema;
  //   // if (schema !== this._rootSchema) {
  //   //   const typed = JSON.parse(JSON.stringify({ type: param.type, ofType: param.ofType }));
  //   //   setInnerType(typed, getInnerType(typed));
  //   // }
  //   return new RefTraversal(argValue, this._rootSchema, this.schemaTraversal.getTypedForParam(name));
  // }
  // Information about the current position within the ref and schema
  get pathElem() {
    return this._ref.path.get(this._index);
  }
  get ref() {
    return this._ref.withPath(this._ref.path.slice(0, this._index + 1));
  }
  get name() {
    return this.pathElem && this.pathElem.name;
  }
  get args() {
    return this.pathElem && this.pathElem.args;
  }
  get type() {
    return this._schemaTraversal.getCurrentType();
  }
  // get paramsType() { return this._schemaTraversal.getParamsType(); }
  get schema() {
    return this._schemaTraversal.getCurrentSchema();
  }
  get isRef() {
    return this._schemaTraversal.isRef();
  }
  get isList() {
    return this._schemaTraversal.isList();
  }
  get wrappers() {
    return this._schemaTraversal.getWrappers();
  }
  get typed() {
    return this._schemaTraversal.getTyped();
  }
  get fullTypeName() {
    return this._schemaTraversal.fullTypeName;
  }
  get paramsFullTypeName() {
    return this._schemaTraversal.paramsFullTypeName;
  }
  get member() {
    return this._schemaTraversal.member;
  }
  get schemaTraversal() {
    return this._schemaTraversal.clone();
  }
}
exports.default = RefTraversal;