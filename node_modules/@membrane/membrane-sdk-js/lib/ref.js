"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.$$ = $$;
exports.Ref = exports.PathElem = exports.EMPTY_REF = void 0;
var _immutable = _interopRequireDefault(require("immutable"));
var _refParser = require("./refParser.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Serializes the provided value into its literal ref version
function serializeValue(value, isGraphQL) {
  if (value instanceof Ref) {
    if (isGraphQL) {
      return `"${value.toString().replace(/"/g, '\\"')}"`;
    }
    return `[${value}]`;
  } else if (typeof value === 'string') {
    return `"${value}"`;
  }
  return `${value}`;
}

// An element in a ref's path
class PathElem extends _immutable.default.Record({
  name: '',
  args: _immutable.default.Map()
}) {
  withArgs(args) {
    if (!_immutable.default.Map.isMap(args)) {
      args = _immutable.default.Map(args);
    }
    let newElem = this.set('args', args);

    // HACK: using the ref parser to validate for now but we should use a more
    // efficient method later
    $$(':' + newElem.toString());
    return newElem;
  }
  _toString(isGraphQL) {
    let result = this.name;
    if (this.args.size > 0) {
      result += `(${this.argsToString(isGraphQL)})`;
    }
    return result;
  }
  argsToString(isGraphQL) {
    return this.args.sortBy((value, key) => key).map((value, key) => `${key}:${serializeValue(value, isGraphQL)}`).join(',');
  }
  argsToGraphQLArg() {
    return this.argsToString(true);
  }
  toGraphQLArgs() {
    return this._toString(true);
  }
  toString() {
    return this._toString(false);
  }
}

// Ref to a graph node in Membrane. Implemented on immutable.js.
exports.PathElem = PathElem;
class Ref extends _immutable.default.Record({
  program: '',
  path: _immutable.default.List()
}) {
  _ensureIndexInRange(i) {
    if (i >= this.path.length || i < -this.path.size) {
      throw new Error('Path element index out of range');
    }
  }

  // Pretty prints this ref. Needed so that we can implement toGraphQLArgs in
  // terms of toString
  _toString(isGraphQL) {
    return `${this.program}:${this.path.map(pathElem => pathElem._toString(isGraphQL)).join('.')}`;
  }

  // Pretty prints this ref
  toString() {
    return this._toString(false);
  }
  toJSON() {
    return {
      $ref: this.toString()
    };
  }

  // Same as toString but refs are passed as strings instead of square brackets
  toGraphQLArgs() {
    return this._toString(true);
  }

  // get $ref() {
  //   return ':';
  //   // console.log('Getting ref');
  //   // return this._toString(false);
  // }

  is(other) {
    return _immutable.default.is(this, other);
  }
  isNull() {
    return this.program === 'null';
  }
  clone() {
    throw new Error('Ref.clone() IS DEPRECATED');
  }
  static _validate(ref) {
    $$(ref.toString());
  }

  // Returns the same ref but with a different program
  withProgram(name) {
    const result = this.set('program', name);
    Ref._validate(result);
    return result;
  }

  // Sets the program to the empty string
  withoutProgram() {
    return this.set('program', undefined);
  }

  // Sets the path to the empty list
  withoutPath() {
    return this.set('path', undefined);
  }

  // Returns the same ref as this one but with one of the  last args (or as
  // specified by pathElemIndex) replaced with the provided one
  withArg(name, value, pathElemIndex = -1) {
    this._ensureIndexInRange(pathElemIndex);
    let result;
    if (value === undefined) {
      result = this.deleteIn(['path', pathElemIndex, 'args', name]);
    } else {
      result = this.setIn(['path', pathElemIndex, 'args', name], value);
    }
    Ref._validate(result);
    return result;
  }

  // Returns the same ref as this one but with the last args (or as specified by
  // pathElemIndex) replaced with the provided ones
  withArgs(args, pathElemIndex = -1) {
    if (!_immutable.default.Map.isMap(args)) {
      if (typeof args !== 'object') {
        throw new Error('Arguments of ref can only be plain objects or maps');
      }
      args = _immutable.default.Map(args);
    }
    this._ensureIndexInRange(pathElemIndex);
    const result = this.setIn(['path', pathElemIndex, 'args'], _immutable.default.Map(args));
    Ref._validate(result);
    return result;
  }
  withoutArgs() {
    if (this.path.size === 0) {
      return this;
    }
    return this.setIn(['path', -1, 'args'], _immutable.default.Map());
  }
  withPath(path) {
    const result = this.set('path', path);
    Ref._validate(result);
    return result;
  }

  // Returns the concatenation of the provided ref after this ref
  concat(other) {
    const result = this.set('path', this.path.concat(other.path));
    Ref._validate(result);
    return result;
  }

  // Returns the concatenation of this ref after the provided ref
  rebase(other) {
    const result = other.concat(this);
    Ref._validate(result);
    return result;
  }

  // Returns this reference as relative to another one:
  //   "a:b.c.d.e" relative to "a:b.c" with name "1" returns "1:d.e"
  relativeTo(other, otherName) {
    if (other.program !== this.program) {
      throw new Error('Ref cannot be expressed as relative to ref that points to another program');
    }
    const result = new Ref({
      program: otherName || other.program,
      path: this.path.skipWhile((value, index) => {
        const otherValue = other.path.get(index);
        if (_immutable.default.is(value, otherValue)) {
          return true;
        }
        if (otherValue === undefined) {
          return false;
        }
        throw new Error('Ref cannot be expressed as relative to provided ref');
      })
    });
    Ref._validate(result);
    return result;
  }

  // Whether this ref is a prefix of another one
  isPrefix(other) {
    if (this.program !== other.program) {
      return false;
    }
    return this.path.every((p1, i) => {
      const p2 = other.path.get(i);
      if (p2 === undefined) {
        return false;
      }
      let result = p1.name === p2.name;
      if (p1.args.size !== 0) {
        result = _immutable.default.is(p1.args, p2.args);
      }
      return result;
    });
  }

  // Gets the last element in the path
  last() {
    return this.path.get(-1);
  }
  push(name, args) {
    const pathElem = new PathElem({
      name,
      args: new _immutable.default.Map(args)
    });
    const result = this.updateIn(['path'], p => p.push(pathElem));
    Ref._validate(result);
    return result;
  }

  // Pops the last element in the path, if path is empty, returns the empty ref
  pop() {
    if (this.path.size) {
      return this.updateIn(['path'], p => p.pop());
    }
    return this.delete('program');
  }
  shift() {
    if (this.path.size) {
      return this.updateIn(['path'], path => path.shift());
    }
    return this.delete('program');
  }

  // Returns a JS object with the args at the provided ref
  argsAt(ref) {
    if (typeof ref === 'string') {
      ref = $$(ref);
    }
    if (ref.path.size > this.path.size || ref.path.size === 0) {
      return {};
    }
    for (let i = 0; i < ref.path.size; ++i) {
      if (this.path.get(i).name !== ref.path.get(i).name) {
        // A provided path element does not match the ones in this ref
        return {};
      }
    }
    return this.path.get(ref.path.size - 1).args.toObject();
  }
}

// An empty ref
exports.Ref = Ref;
const EMPTY_REF = new Ref();

// Creates a Ref object. The argument can be:
// - undefined (returns the ":" ref)
// - string
// - another ref
exports.EMPTY_REF = EMPTY_REF;
function $$(r) {
  let ast;
  if (r instanceof Ref) {
    return r;
  }
  // if (r === undefined || r === null) {
  //   throw new Error('Refs cannot be built from ' + r);
  // }
  const looksLikeRef = r && _immutable.default.Record.isRecord(r) && typeof r.program === 'string' && _immutable.default.List.isList(r.path) && r.toString;
  if (looksLikeRef) {
    ast = new _refParser.RefParser(r.toString()).parse();
  } else if (typeof r === 'string') {
    ast = new _refParser.RefParser(r).parse();
  } else if (r && r.$ref && typeof r.$ref === 'string') {
    ast = new _refParser.RefParser(r.$ref).parse();
  } else {
    debugger;
    throw new Error('Refs can only be constructed from another Ref, a string, or an object with a $ref property, got: ' + (r === null ? 'null' : typeof r));
  }
  return refFromAst(ast);
}

// Creates a ref given a parsed string's AST
function refFromAst(ast) {
  const path = _immutable.default.List(ast.path.value.map(pathElemAst => {
    const args = {};
    for (let arg of pathElemAst.args.value) {
      if (arg.value.type === 'ref') {
        args[arg.name.value] = refFromAst(arg.value.value);
      } else {
        args[arg.name.value] = arg.value.value;
      }
    }
    return new PathElem({
      name: pathElemAst.name.value,
      args: new _immutable.default.Map(args)
    });
  }));
  const program = ast.program.value;
  return new Ref({
    program,
    path
  });
}